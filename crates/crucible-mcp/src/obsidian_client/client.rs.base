// Example HTTP Client Implementation for Integration Tests
// File: crates/crucible-mcp/tests/integration/http_client.rs

use reqwest::{Client, Response, StatusCode};
use serde::{Deserialize, Serialize};
use std::time::Duration;
use anyhow::{Result, Context};
use tracing::{debug, warn};

#[derive(Clone)]
pub struct ObsidianClient {
    client: Client,
    base_url: String,
    retry_config: RetryConfig,
}

#[derive(Clone)]
pub struct RetryConfig {
    pub max_retries: u32,
    pub initial_backoff: Duration,
    pub max_backoff: Duration,
    pub timeout: Duration,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_retries: 3,
            initial_backoff: Duration::from_millis(100),
            max_backoff: Duration::from_secs(5),
            timeout: Duration::from_secs(30),
        }
    }
}

impl ObsidianClient {
    pub fn new(port: u16) -> Result<Self> {
        let client = Client::builder()
            .timeout(Duration::from_secs(30))
            .pool_max_idle_per_host(10)
            .build()?;
        
        Ok(Self {
            client,
            base_url: format!("http://localhost:{}", port),
            retry_config: RetryConfig::default(),
        })
    }

    pub async fn list_files(&self) -> Result<Vec<FileInfo>> {
        self.retry_request(|| async {
            let response = self.client
                .get(&format!("{}/api/files", self.base_url))
                .send()
                .await?;
            
            let data: ListFilesResponse = self.handle_response(response).await?;
            Ok(data.files)
        }).await
    }

    pub async fn search_by_tags(&self, tags: &[String]) -> Result<Vec<FileInfo>> {
        self.retry_request(|| async {
            let mut url = format!("{}/api/search/tags", self.base_url);
            for (i, tag) in tags.iter().enumerate() {
                let prefix = if i == 0 { "?" } else { "&" };
                url.push_str(&format!("{}tags[]={}", prefix, urlencoding::encode(tag)));
            }
            
            let response = self.client.get(&url).send().await?;
            let data: SearchResponse = self.handle_response(response).await?;
            Ok(data.files)
        }).await
    }

    async fn retry_request<F, Fut, T>(&self, mut request_fn: F) -> Result<T>
    where
        F: FnMut() -> Fut,
        Fut: std::future::Future<Output = Result<T>>,
    {
        let mut retries = 0;
        let mut backoff = self.retry_config.initial_backoff;

        loop {
            match request_fn().await {
                Ok(result) => return Ok(result),
                Err(e) if retries < self.retry_config.max_retries && Self::is_retriable(&e) => {
                    warn!("Request failed (attempt {}/{}): {}", retries + 1, self.retry_config.max_retries, e);
                    tokio::time::sleep(backoff).await;
                    backoff = std::cmp::min(backoff * 2, self.retry_config.max_backoff);
                    retries += 1;
                }
                Err(e) => return Err(e),
            }
        }
    }

    fn is_retriable(error: &anyhow::Error) -> bool {
        if let Some(reqwest_err) = error.downcast_ref::<reqwest::Error>() {
            return reqwest_err.is_timeout() 
                || reqwest_err.is_connect() 
                || reqwest_err.status()
                    .map(|s| s.is_server_error() || s == StatusCode::TOO_MANY_REQUESTS)
                    .unwrap_or(false);
        }
        false
    }

    async fn handle_response<T: for<'de> Deserialize<'de>>(&self, response: Response) -> Result<T> {
        let status = response.status();
        if status.is_success() {
            response.json::<T>().await.context("Failed to parse JSON response")
        } else {
            let error_body = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
            Err(anyhow::anyhow!("HTTP {} - {}", status, error_body))
        }
    }
}

#[derive(Debug, Deserialize, Serialize)]
pub struct FileInfo {
    pub path: String,
    pub name: String,
    pub folder: String,
    pub size: u64,
}

#[derive(Debug, Deserialize)]
struct ListFilesResponse {
    files: Vec<FileInfo>,
}

#[derive(Debug, Deserialize)]
struct SearchResponse {
    files: Vec<FileInfo>,
}
