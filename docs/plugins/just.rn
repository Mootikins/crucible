// Just recipe discovery and execution plugin
//
// This plugin discovers recipes from justfiles and exposes them as tools.
// It uses the struct-based plugin pattern with #[plugin(...)] attribute.
//
// Note: Uses oq::query with to_entries to work around Rune's limitation
// with iterating over nested objects from JSON.

use shell::exec;
use oq::query;

struct JustPlugin {
    recipes,
}

impl JustPlugin {
    /// Create a new plugin, discovering recipes from justfile
    fn new() {
        let result = exec("just", ["--dump", "--dump-format", "json"], #{});

        // Handle exec failure (just not installed or no justfile)
        if result.is_err() {
            return JustPlugin { recipes: [] };
        }

        let result = result.unwrap();
        if result.exit_code != 0 {
            // No justfile or just error
            return JustPlugin { recipes: [] };
        }

        // Use query with to_entries to convert recipes object to array
        // Filter out private recipes and extract relevant fields
        let entries = query(result.stdout, ".recipes | to_entries | map(select(.value.private != true))");
        if entries.is_err() {
            return JustPlugin { recipes: [] };
        }

        let entries = entries.unwrap();
        if entries == () {
            return JustPlugin { recipes: [] };
        }

        // Build recipe array
        let recipes = [];
        for entry in entries {
            let name = entry["key"];
            let recipe = entry["value"];

            recipes.push(#{
                name: name,
                doc: recipe["doc"],
                parameters: recipe["parameters"],
            });
        }

        JustPlugin { recipes }
    }

    /// Return tool definitions for all discovered recipes
    fn tools(self) {
        let tool_list = [];

        for recipe in self.recipes {
            let name = recipe["name"];
            let doc = recipe["doc"];
            let params = recipe["parameters"];

            // Build parameter definitions
            let param_list = [];
            if params != () {
                for param in params {
                    let param_name = param["name"];
                    let has_default = param["default"] != ();

                    param_list.push(#{
                        name: param_name,
                        description: `Parameter '${param_name}'`,
                        required: !has_default,
                    });
                }
            }

            // Build tool definition
            let description = if doc != () { doc } else { `Run just recipe '${name}'` };

            tool_list.push(#{
                name: `just_${name}`,
                description: description,
                parameters: param_list,
            });
        }

        tool_list
    }

    /// Dispatch a tool call to run a recipe
    fn dispatch(self, tool_name, args) {
        // Extract recipe name from tool name (remove "just_" prefix)
        if !tool_name.starts_with("just_") {
            return #{ error: `Unknown tool: ${tool_name}` };
        }

        let recipe_name = tool_name[5..];  // Skip "just_"

        // Find recipe in our list
        let recipe = ();
        for r in self.recipes {
            if r["name"] == recipe_name {
                recipe = r;
                break;
            }
        }

        if recipe == () {
            return #{ error: `Recipe not found: ${recipe_name}` };
        }

        // Build command arguments
        let cmd_args = [recipe_name];

        // Add positional arguments from recipe parameters
        let params = recipe["parameters"];
        if params != () {
            for param in params {
                let param_name = param["name"];
                let value = args[param_name];
                if value != () {
                    cmd_args.push(value);
                }
            }
        }

        // Run the recipe
        let result = exec("just", cmd_args, #{});
        if result.is_err() {
            return #{ error: result.unwrap_err() };
        }

        let result = result.unwrap();
        #{
            exit_code: result.exit_code,
            stdout: result.stdout,
            stderr: result.stderr,
        }
    }
}

/// Factory function - Crucible discovers this via #[plugin(...)] attribute
#[plugin(watch = ["justfile", "*.just", ".justfile"])]
pub fn create() {
    JustPlugin::new()
}
