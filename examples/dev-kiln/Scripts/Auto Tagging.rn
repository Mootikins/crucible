// Auto Tagging Script
// Automatically suggests and applies tags based on note content
//
// Usage:
//   cru script "Scripts/Auto Tagging.rn" --note "My Note.md"

/// Analyze note content and suggest relevant tags
pub fn suggest_tags(content) {
    let suggestions = [];

    // Check for common patterns
    if content.contains("TODO") || content.contains("FIXME") {
        suggestions.push("actionable");
    }

    if content.contains("```") {
        suggestions.push("has-code");
    }

    if content.contains("[[") {
        suggestions.push("linked");
    }

    // Check for content types
    if content.contains("# Meeting") || content.contains("## Attendees") {
        suggestions.push("meeting-notes");
    }

    if content.contains("# Decision") || content.contains("## Options") {
        suggestions.push("decision");
    }

    if content.contains("# Daily") || content.contains("## Today") {
        suggestions.push("daily-note");
    }

    // Check for project indicators
    if content.contains("deadline") || content.contains("due date") {
        suggestions.push("has-deadline");
    }

    if content.contains("blocked") || content.contains("waiting on") {
        suggestions.push("blocked");
    }

    suggestions
}

/// Check if note already has a tag
pub fn has_tag(frontmatter, tag) {
    if let Some(tags) = frontmatter.get("tags") {
        tags.contains(tag)
    } else {
        false
    }
}

/// Main entry point
pub fn main(note_path) {
    // Read the note
    let note = crucible::read_note(note_path)?;

    // Get current tags
    let current_tags = note.frontmatter.get("tags").unwrap_or([]);

    // Suggest new tags
    let suggestions = suggest_tags(note.content);

    // Filter out existing tags
    let new_tags = [];
    for tag in suggestions {
        if !current_tags.contains(tag) {
            new_tags.push(tag);
        }
    }

    if new_tags.is_empty() {
        println("No new tags to suggest for {}", note_path);
        return Ok(());
    }

    // Report suggestions
    println("Suggested tags for {}:", note_path);
    for tag in new_tags {
        println("  - #{}", tag);
    }

    // In act mode, apply the tags
    if crucible::is_act_mode() {
        let updated_tags = current_tags + new_tags;
        crucible::update_frontmatter(note_path, #{
            tags: updated_tags
        })?;
        println("Tags applied!");
    } else {
        println("Run with --act to apply tags");
    }

    Ok(())
}
