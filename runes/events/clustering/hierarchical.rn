/// Hierarchical clustering plugin for Crucible
///
/// This plugin implements agglomerative hierarchical clustering for documents,
/// creating a dendrogram that can be cut at different levels to get varying
/// numbers of clusters.
///
/// Features:
/// - Agglomerative (bottom-up) clustering
/// - Multiple linkage criteria (single, complete, average)
/// - Dendrogram visualization support
/// - Automatic optimal level detection

// ===== HIERARCHICAL CLUSTERING IMPLEMENTATION =====

/// Types of linkage criteria for hierarchical clustering
enum LinkageType {
    SINGLE,     // Minimum distance between clusters
    COMPLETE,   // Maximum distance between clusters
    AVERAGE,    // Average distance between clusters
    WARD        // Ward's method (minimum variance)
}

/// Calculate distance matrix for all document pairs
pub fn calculate_distance_matrix(features) {
    let n = features.len();
    let mut matrix = vec![vec![0.0; n]; n];

    for i in 0..n {
        for j in i..n {
            if i == j {
                matrix[i][j] = 0.0;
            } else {
                let dist = euclidean_distance(features[i], features[j]);
                matrix[i][j] = dist;
                matrix[j][i] = dist;
            }
        }
    }

    matrix
}

/// Euclidean distance between two vectors
pub fn euclidean_distance(a, b) {
    if a.len() != b.len() {
        panic!("Vectors must have same dimension");
    }

    let mut sum = 0.0;
    for i in 0..a.len() {
        let diff = a[i] - b[i];
        sum += diff * diff;
    }
    sqrt(sum)
}

/// Single linkage: minimum distance between clusters
pub fn single_linkage(cluster1, cluster2, distance_matrix) {
    let mut min_dist = f64::MAX;

    for i in cluster1 {
        for j in cluster2 {
            if distance_matrix[i][j] < min_dist {
                min_dist = distance_matrix[i][j];
            }
        }
    }

    min_dist
}

/// Complete linkage: maximum distance between clusters
pub fn complete_linkage(cluster1, cluster2, distance_matrix) {
    let mut max_dist = 0.0;

    for i in cluster1 {
        for j in cluster2 {
            if distance_matrix[i][j] > max_dist {
                max_dist = distance_matrix[i][j];
            }
        }
    }

    max_dist
}

/// Average linkage: average distance between clusters
pub fn average_linkage(cluster1, cluster2, distance_matrix) {
    let mut total_dist = 0.0;
    let mut count = 0;

    for i in cluster1 {
        for j in cluster2 {
            total_dist += distance_matrix[i][j];
            count += 1;
        }
    }

    total_dist / count as f64
}

/// Ward's method: minimum variance criterion
pub fn ward_linkage(cluster1, cluster2, distance_matrix, features) {
    let n1 = cluster1.len();
    let n2 = cluster2.len();
    let n = n1 + n2;

    // Calculate centroids
    let mut centroid1 = vec![0.0; features[0].len()];
    let mut centroid2 = vec![0.0; features[0].len()];

    for i in cluster1 {
        for d in 0..centroid1.len() {
            centroid1[d] += features[i][d];
        }
    }

    for i in cluster2 {
        for d in 0..centroid2.len() {
            centroid2[d] += features[i][d];
        }
    }

    for d in 0..centroid1.len() {
        centroid1[d] /= n1 as f64;
        centroid2[d] /= n2 as f64;
    }

    // Calculate Ward distance
    let mut distance = 0.0;
    for d in 0..centroid1.len() {
        let diff = centroid1[d] - centroid2[d];
        distance += diff * diff;
    }

    distance * n1 * n2 / n as f64
}

/// Perform hierarchical clustering
pub fn hierarchical_cluster(features, linkage_type, max_clusters) {
    if features.is_empty() {
        panic!("Features cannot be empty");
    }

    let n = features.len();
    let distance_matrix = calculate_distance_matrix(features);

    // Initialize: each point in its own cluster
    let mut clusters = [];
    for i in 0..n {
        clusters.push([i]);
    }

    // Store merge history for dendrogram
    let mut dendrogram = [];
    let mut distances = [];

    // Iteratively merge closest clusters
    while clusters.len() > max_clusters && clusters.len() > 1 {
        let mut min_dist = f64::MAX;
        let mut merge_i = 0;
        let mut merge_j = 0;

        // Find closest pair of clusters
        for i in 0..clusters.len() {
            for j in i + 1..clusters.len() {
                let dist = match linkage_type {
                    LinkageType::SINGLE => single_linkage(clusters[i], clusters[j], distance_matrix),
                    LinkageType::COMPLETE => complete_linkage(clusters[i], clusters[j], distance_matrix),
                    LinkageType::AVERAGE => average_linkage(clusters[i], clusters[j], distance_matrix),
                    LinkageType::WARD => ward_linkage(clusters[i], clusters[j], distance_matrix, features)
                };

                if dist < min_dist {
                    min_dist = dist;
                    merge_i = i;
                    merge_j = j;
                }
            }
        }

        if merge_j < merge_i {
            let temp = merge_i;
            merge_i = merge_j;
            merge_j = temp;
        }

        // Merge clusters
        let merged_cluster = [];
        for idx in clusters[merge_i] {
            merged_cluster.push(idx);
        }
        for idx in clusters[merge_j] {
            merged_cluster.push(idx);
        }

        // Record merge
        dendrogram.push([clusters[merge_i], clusters[merge_j], merged_cluster]);
        distances.push(min_dist);

        // Update cluster list
        clusters[merge_i] = merged_cluster;
        clusters.remove(merge_j);
    }

    // Calculate cluster statistics
    let mut stats = [];
    for i in 0..clusters.len() {
        stats.push({
            "id": i,
            "size": clusters[i].len(),
            "documents": clusters[i].clone()
        });
    }

    {
        "linkage_type": linkage_type,
        "num_clusters": clusters.len(),
        "clusters": clusters,
        "stats": stats,
        "dendrogram": dendrogram,
        "merge_distances": distances
    }
}

// ===== CLUSTER VALIDATION =====

/// Calculate cophenetic correlation coefficient
/// Measures how well the dendrogram preserves pairwise distances
pub fn cophenetic_correlation(dendrogram, merge_distances, original_distances) {
    let n = original_distances.len();
    let mut cophenetic = vec![vec![0.0; n]; n];

    // Build cophenetic distance matrix
    for i in 0..n {
        for j in 0..n {
            cophenetic[i][j] = find_cophenetic_distance(i, j, dendrogram, merge_distances);
        }
    }

    // Calculate correlation with original distances
    let mut mean_orig = 0.0;
    let mut mean_coph = 0.0;
    let mut count = 0;

    for i in 0..n {
        for j in i + 1..n {
            mean_orig += original_distances[i][j];
            mean_coph += cophenetic[i][j];
            count += 1;
        }
    }

    mean_orig /= count as f64;
    mean_coph /= count as f64;

    let mut numerator = 0.0;
    let mut denom_orig = 0.0;
    let mut denom_coph = 0.0;

    for i in 0..n {
        for j in i + 1..n {
            let diff_orig = original_distances[i][j] - mean_orig;
            let diff_coph = cophenetic[i][j] - mean_coph;

            numerator += diff_orig * diff_coph;
            denom_orig += diff_orig * diff_orig;
            denom_coph += diff_coph * diff_coph;
        }
    }

    if denom_orig == 0.0 || denom_coph == 0.0 {
        0.0
    } else {
        numerator / sqrt(denom_orig * denom_coph)
    }
}

/// Find cophenetic distance between two points in the dendrogram
pub fn find_cophenetic_distance(i, j, dendrogram, merge_distances) {
    // For now, return the merge distance when i and j are first merged
    // This is a simplified implementation
    for step in 0..dendrogram.len() {
        let cluster = dendrogram[step][2];
        let mut has_i = false;
        let mut has_j = false;

        for idx in cluster {
            if idx == i { has_i = true; }
            if idx == j { has_j = true; }
        }

        if has_i && has_j {
            return merge_distances[step];
        }
    }

    0.0
}

// ===== DENDROGRAM VISUALIZATION =====

/// Generate ASCII dendrogram representation
pub fn ascii_dendrogram(dendrogram, merge_distances) {
    if dendrogram.is_empty() {
        return "";
    }

    let mut lines = [];
    let max_dist = merge_distances[merge_distances.len() - 1];

    for step in 0..dendrogram.len().min(10) {  // Limit to first 10 merges for readability
        let cluster1 = dendrogram[step][0];
        let cluster2 = dendrogram[step][1];
        let dist = merge_distances[step];
        let height = (dist / max_dist * 10.0) as int;

        lines.push(format!(
            "Step {}: Merge {} + {} at distance {:.2}",
            step + 1,
            format_cluster(cluster1),
            format_cluster(cluster2),
            dist
        ));

        // Add visual representation
        let mut visual = " ".repeat(height) + "┌─";
        lines.push(visual);
    }

    lines.join("\n")
}

/// Format cluster for display
pub fn format_cluster(cluster) {
    if cluster.len() <= 3 {
        "{" + cluster.map(|x| str(x)).join(",") + "}"
    } else {
        "{" + str(cluster[0]) + ",...," + str(cluster[cluster.len() - 1]) + "}"
    }
}

// ===== MAIN PLUGIN ENTRY POINT =====

/// Main function for hierarchical clustering
pub fn cluster_documents(documents, linkage_type, max_clusters) {
    // Convert documents to feature vectors (reuse from kmeans)
    let features = documents_to_features(documents);

    if features.is_empty() {
        return {
            "error": "No documents to cluster",
            "clusters": []
        };
    }

    // Parse linkage type
    let linkage = match linkage_type {
        "single" => LinkageType::SINGLE,
        "complete" => LinkageType::COMPLETE,
        "average" => LinkageType::AVERAGE,
        "ward" => LinkageType::WARD,
        _ => LinkageType::AVERAGE  // Default
    };

    // Determine reasonable max_clusters
    let max_k = if max_clusters && max_clusters > 1 {
        max_clusters.min(features.len())
    } else {
        // Use sqrt(n) as default
        max(2, (sqrt(features.len() as f64) as int))
    };

    // Run hierarchical clustering
    let result = hierarchical_cluster(features, linkage, max_k);

    // Calculate quality metrics
    let original_distances = calculate_distance_matrix(features);
    let cophenetic_corr = cophenetic_correlation(
        result["dendrogram"],
        result["merge_distances"],
        original_distances
    );

    // Format output clusters
    let mut output_clusters = [];
    for i in 0..result["clusters"].len() {
        let cluster = result["clusters"][i];
        let mut doc_refs = [];

        for doc_idx in cluster {
            doc_refs.push({
                "id": doc_idx,
                "title": documents[doc_idx]["title"],
                "path": documents[doc_idx]["path"]
            });
        }

        output_clusters.push({
            "cluster_id": i,
            "documents": doc_refs,
            "size": cluster.len()
        });
    }

    // Sort clusters by size (largest first)
    output_clusters.sort(|a, b| b["size"] - a["size"]);

    {
        "algorithm": "hierarchical",
        "linkage_type": linkage_type,
        "num_clusters": result["num_clusters"],
        "cophenetic_correlation": cophenetic_corr,
        "clusters": output_clusters,
        "total_documents": documents.len(),
        "dendrogram": ascii_dendrogram(result["dendrogram"], result["merge_distances"]),
        "cluster_stats": result["stats"]
    }
}

// Import documents_to_features from kmeans module
// In a real implementation, this would be shared
pub fn documents_to_features(documents) {
    let mut features = [];
    let dimension = 384;

    for doc in documents {
        let mut vector = vec![0.0; dimension];

        if doc.has("embedding") {
            let embedding = doc["embedding"];
            for i in 0..dimension.min(embedding.len()) {
                vector[i] = embedding[i] * 0.5;  // Content weight
            }
        }

        features.push(vector);
    }

    features
}