/// Graph-based clustering plugin for Crucible
///
/// This plugin implements clustering algorithms that work on the document
/// link graph, focusing on community detection and centrality-based
/// clustering methods.
///
/// Features:
/// - Louvain community detection
/// - PageRank-based clustering
/// - Link-based similarity clustering
/// - Centrality analysis

// ===== GRAPH DATA STRUCTURES =====

/// Directed graph representation
struct Graph {
    nodes: [],           // List of node IDs
    edges: {},           // Map: node_id -> [outgoing_edges]
    in_edges: {},        // Map: node_id -> [incoming_edges]
    weights: {},         // Map: (from, to) -> edge_weight
}

/// Create new graph
pub fn new_graph() {
    {
        "nodes": [],
        "edges": {},
        "in_edges": {},
        "weights": {}
    }
}

/// Add node to graph
pub fn add_node(graph, node_id) {
    if !graph["nodes"].contains(node_id) {
        graph["nodes"].push(node_id);
        graph["edges"][node_id] = [];
        graph["in_edges"][node_id] = [];
    }
}

/// Add directed edge with weight
pub fn add_edge(graph, from, to, weight) {
    add_node(graph, from);
    add_node(graph, to);

    graph["edges"][from].push(to);
    graph["in_edges"][to].push(from);
    graph["weights"][from + "," + to] = weight || 1.0;
}

/// Get edge weight
pub fn get_edge_weight(graph, from, to) {
    graph["weights"][from + "," + to] || 0.0
}

/// Build graph from documents
pub fn build_document_graph(documents) {
    let graph = new_graph();
    let doc_map = {};

    // Map document paths to node IDs
    for i in 0..documents.len() {
        let path = documents[i]["path"];
        doc_map[path] = i;
        add_node(graph, i);
    }

    // Add edges based on links
    for i in 0..documents.len() {
        let doc = documents[i];

        if doc.has("links") {
            for link in doc["links"] {
                // Try to resolve link to document path
                if doc_map.has(link) {
                    let target = doc_map[link];
                    // Weight edges by link importance
                    let weight = calculate_link_weight(doc, documents[target]);
                    add_edge(graph, i, target, weight);
                }
            }
        }
    }

    graph
}

/// Calculate link weight based on document properties
pub fn calculate_link_weight(source_doc, target_doc) {
    let base_weight = 1.0;

    // Boost weight for links to MoCs
    if target_doc.has("is_moc") && target_doc["is_moc"] {
        base_weight * 2.0
    }

    // Boost weight for bidirectional links
    if source_doc.has("links") && source_doc["links"].contains(target_doc["path"]) {
        base_weight * 1.5
    }

    // Adjust based on link frequency in source
    if source_doc.has("link_frequency") {
        base_weight / (1.0 + source_doc["link_frequency"]);
    }

    base_weight
}

// ===== LOUVAIN COMMUNITY DETECTION =====

/// Run Louvain community detection
pub fn louvain_communities(graph, resolution) {
    let n = graph["nodes"].len();
    let mut communities = {};
    let mut node_communities = vec[];

    // Initialize each node in its own community
    for node in graph["nodes"] {
        communities[node] = [node];
        node_communities[node] = node;
    }

    let mut improved = true;
    let iterations = 0;

    while improved && iterations < 100 {
        improved = false;
        iterations += 1;

        // Phase 1: Local optimization
        for node in graph["nodes"] {
            let best_community = find_best_community(
                graph, node, node_communities[node], communities, resolution
            );

            if best_community != node_communities[node] {
                // Move node to best community
                let old_community = node_communities[node];
                communities[old_community].remove(node);

                if communities[old_community].is_empty() {
                    communities.remove(old_community);
                }

                communities[best_community].push(node);
                node_communities[node] = best_community;
                improved = true;
            }
        }
    }

    // Convert communities to output format
    let mut clusters = [];
    for community_id in communities.keys() {
        let community = communities[community_id];
        let mut cluster_docs = [];

        for node_id in community {
            cluster_docs.push({
                "id": node_id,
                "path": graph["nodes"][node_id]
            });
        }

        clusters.push({
            "id": clusters.len(),
            "documents": cluster_docs,
            "size": community.len(),
            "modularity": calculate_modularity(graph, node_communities)
        });
    }

    // Sort by size
    clusters.sort(|a, b| b["size"] - a["size"]);

    {
        "algorithm": "louvain",
        "num_communities": clusters.len(),
        "clusters": clusters,
        "iterations": iterations,
        "resolution": resolution
    }
}

/// Find best community for a node
pub fn find_best_community(graph, node, current_community, communities, resolution) {
    let best_community = current_community;
    let best_modularity = calculate_modularity_gain(
        graph, node, current_community, communities, resolution
    );

    // Check neighboring communities
    for neighbor in graph["edges"][node] {
        let neighbor_community = find_community_of_node(neighbor, communities);

        if neighbor_community != current_community {
            let modularity_gain = calculate_modularity_gain(
                graph, node, neighbor_community, communities, resolution
            );

            if modularity_gain > best_modularity {
                best_modularity = modularity_gain;
                best_community = neighbor_community;
            }
        }
    }

    best_community
}

/// Find which community a node belongs to
pub fn find_community_of_node(node, communities) {
    for community_id in communities.keys() {
        if communities[community_id].contains(node) {
            return community_id;
        }
    }
    -1
}

/// Calculate modularity of current partition
pub fn calculate_modularity(graph, node_communities) {
    let m = count_total_edges(graph);
    if m == 0 { return 0.0; }

    let mut modularity = 0.0;

    for node1 in graph["nodes"] {
        for node2 in graph["edges"][node1] {
            if node_communities[node1] == node_communities[node2] {
                let k1 = graph["edges"][node1].len();
                let k2 = graph["in_edges"][node2].len();
                modularity += (1.0 / m) - ((k1 * k2) / (m * m));
            }
        }
    }

    modularity / 2.0
}

/// Calculate modularity gain for moving a node
pub fn calculate_modularity_gain(graph, node, new_community, communities, resolution) {
    // Simplified calculation
    let k_i = graph["edges"][node].len() + graph["in_edges"][node].len();
    let k_c = 0;  // Sum of degrees in community

    let sum_in = 0;  // Internal edges to community
    let sum_tot = 0;  // Total edges to/from community

    // Calculate these metrics for the community
    for community_node in communities[new_community] {
        k_c += graph["edges"][community_node].len() + graph["in_edges"][community_node].len();

        // Check internal connections
        if graph["edges"][node].contains(community_node) {
            sum_in += get_edge_weight(graph, node, community_node);
        }
        if graph["edges"][community_node].contains(node) {
            sum_in += get_edge_weight(graph, community_node, node);
        }
    }

    resolution * (sum_in - (k_i * k_c) / (2 * count_total_edges(graph)))
}

/// Count total edges in graph
pub fn count_total_edges(graph) {
    let mut count = 0;
    for node in graph["nodes"] {
        count += graph["edges"][node].len();
    }
    count / 2  // Since we're counting each edge twice
}

// ===== PAGERANK-BASED CLUSTERING =====

/// Calculate PageRank for all nodes
pub fn pagerank(graph, damping_factor, iterations) {
    let n = graph["nodes"].len();
    if n == 0 { return {}; }

    let mut ranks = {};
    let initial_rank = 1.0 / n as f64;

    // Initialize ranks
    for node in graph["nodes"] {
        ranks[node] = initial_rank;
    }

    // Iterate
    for _ in 0..iterations {
        let mut new_ranks = {};

        for node in graph["nodes"] {
            let mut rank = (1.0 - damping_factor) / n as f64;

            // Add contribution from incoming links
            for incoming in graph["in_edges"][node] {
                let outgoing_count = graph["edges"][incoming].len();
                if outgoing_count > 0 {
                    rank += damping_factor * ranks[incoming] / outgoing_count as f64;
                }
            }

            new_ranks[node] = rank;
        }

        ranks = new_ranks;
    }

    ranks
}

/// Cluster based on PageRank similarity
pub fn pagerank_cluster(graph, documents, num_clusters) {
    let ranks = pagerank(graph, 0.85, 100);

    // Sort nodes by PageRank
    let sorted_nodes = graph["nodes"].slice().sort(|a, b| ranks[b] - ranks[a]);

    // Create clusters by grouping top-ranking nodes with their neighbors
    let mut clusters = [];
    let mut assigned = {};

    for i in 0..sorted_nodes.len().min(num_clusters) {
        let central_node = sorted_nodes[i];
        if assigned[central_node] { continue; }

        let mut cluster = [];
        let mut queue = [central_node];

        while !queue.is_empty() {
            let node = queue.pop();
            if assigned[node] { continue; }

            cluster.push(node);
            assigned[node] = true;

            // Add unassigned neighbors
            for neighbor in graph["edges"][node] {
                if !assigned[neighbor] && cluster.len() < 10 {  // Limit cluster size
                    queue.push(neighbor);
                }
            }

            // Also consider backlinks
            for neighbor in graph["in_edges"][node] {
                if !assigned[neighbor] && cluster.len() < 10 {
                    queue.push(neighbor);
                }
            }
        }

        if cluster.len() > 0 {
            clusters.push({
                "central_node": central_node,
                "centrality": ranks[central_node],
                "documents": cluster.map(|x| {
                    "id": x,
                    "title": documents[x]["title"],
                    "path": documents[x]["path"]
                }),
                "size": cluster.len()
            });
        }
    }

    // Add remaining unassigned nodes
    for node in graph["nodes"] {
        if !assigned[node] {
            clusters.push({
                "central_node": node,
                "centrality": ranks[node],
                "documents": [{
                    "id": node,
                    "title": documents[node]["title"],
                    "path": documents[node]["path"]
                }],
                "size": 1
            });
        }
    }

    {
        "algorithm": "pagerank",
        "num_clusters": clusters.len(),
        "clusters": clusters,
        "num_documents": graph["nodes"].len()
    }
}

// ===== MAIN PLUGIN ENTRY POINT =====

/// Main function for graph-based clustering
pub fn cluster_documents(documents, algorithm, params) {
    // Build document graph
    let graph = build_document_graph(documents);

    if graph["nodes"].len() == 0 {
        return {
            "error": "No documents with links to cluster",
            "clusters": []
        };
    }

    // Run selected algorithm
    let result = match algorithm {
        "louvain" => louvain_communities(
            graph,
            params["resolution"] || 1.0
        ),
        "pagerank" => pagerank_cluster(
            graph,
            documents,
            params["num_clusters"] || 5
        ),
        _ => {
            "error": "Unknown algorithm: " + algorithm,
            "available_algorithms": ["louvain", "pagerank"]
        }
    };

    // Add graph statistics
    result["graph_stats"] = {
        "nodes": graph["nodes"].len(),
        "edges": count_total_edges(graph),
        "avg_links_per_doc": (2 * count_total_edges(graph)) / graph["nodes"].len(),
        "connected_components": count_connected_components(graph)
    };

    result
}

/// Count connected components in graph
pub fn count_connected_components(graph) {
    let mut visited = {};
    let mut components = 0;

    for node in graph["nodes"] {
        if !visited[node] {
            components += 1;
            depth_first_search(graph, node, visited);
        }
    }

    components
}

/// Depth-first search to find connected component
pub fn depth_first_search(graph, node, visited) {
    visited[node] = true;

    for neighbor in graph["edges"][node] {
        if !visited[neighbor] {
            depth_first_search(graph, neighbor, visited);
        }
    }

    for neighbor in graph["in_edges"][node] {
        if !visited[neighbor] {
            depth_first_search(graph, neighbor, visited);
        }
    }
}

// Example usage:
// let result = cluster_documents(
//   documents,
//   "louvain",
//   { "resolution": 1.5 }
// );
//
// or
//
// let result = cluster_documents(
//   documents,
//   "pagerank",
//   { "num_clusters": 8 }
// );